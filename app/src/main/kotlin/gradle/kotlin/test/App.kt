/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package gradle.kotlin.test

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

fun main() { // I love to death that functions in Kotlin are all defined by just "fun". fun!! FUN!!!!!!!!
    println(App().greeting)
    // val - value, cannot be changed
    // var - variable, can be changed
    var message: String = """
        Heloooo
        woooorld
    """.trimIndent() // Removes the indent and newline taken from the code
    // Alternatively, use .replaceIndent("#")
    println(message)
    message = """
        Heloooo
        woooorld
    """.replaceIndent("#.")
    println(message)
    /* .trimIndent() can also be replaced with something like .trimMargin(),
        but then we'll have to pass a string of specific characters in the method and
        then write them at the start of each new line, like below. Default char is '|'
    */
    message = """
        >>>Heloooo
        >>>woooorld
    """.trimMargin(">>>")
    println(message)
    val bruh = "123"
    print("helo world: ${App().greeting} and \"123\": $bruh which is ${bruh.length} characters long\n")
//    var isBlank: Boolean = false  this gives a warning that "Boolean" is reduntant and stops a push just to tell it.
    var isBlank = false
    println(isBlank.not())
    isBlank = "".isBlank()
    println(isBlank)

    val yourBasedness = "cringe"
    val myBasedness = "cringe (based)"

    val yourpH = 0f
    val mypH = 14.1f

    if ( (yourBasedness != myBasedness) && (yourpH != mypH) ) {
        println("both checked statements r true")
    }
    // || is or

    var beh1 = "jeff"
    var beh2 = "NOT jeff"

    // structural equality; ; referential equality
    println("${beh1 == beh2} ${beh1.equals(beh2)} ${beh1 === beh2}")

    beh2 = "jeff"

    println("${beh1 == beh2} ${beh1.equals(beh2)} ${beh1 === beh2}")
    // true true true
    // Quoting video, "a Kotlin """caveat""" ": numbers, chars and bools are all primitive types in Kotlin.

    var beh3 = Jeff("jeff")
    var beh4 = Jeff("NOT jeff")

    println("${beh3 == beh4} ${beh3.equals(beh4)} ${beh3 === beh4}")
    println("${beh3.name == beh4.name} ${beh3.name === beh4.name}")

    beh4 = Jeff("jeff")

    println("${beh3 == beh4} ${beh3.equals(beh4)} ${beh3 === beh4}")
    println("${beh3.name == beh4.name} ${beh3.name === beh4.name}")

    var weh1 = Jeff("jeff")
    var weh2 = Jeff("jeff")

    println("${weh1 == weh2} ${weh1 === weh2}")

    /*** null stuff ***/
    var name: String = "Jeff" // not nullable
    var name2: String? = "Jeffuel"
    name2 = null // And thus Jeffuel is no more.
    var aJeff: Jeff? = Jeff("not jeff")
    aJeff = null

    // Checking length of a nullable reference properly - safe call
    val length2 = name2?.length // if it's null, make it null, otherwise give it an integer length
    println(length2) // ...or:
    val length3 = if (name2 != null) name2.length else 0
    println(length3)
    val length4 = name2?.substring(0, 2)?.length
    println(length4)
    var name3: String? = "jeffjeffjeffjeffjeffjeff"
    val length5 = name2?.substring(0,5)?.drop(2)?.substring(2,3)?.length
    print(length5)

    var _lastName: String? = "Riamu"

    var lengthA: Int = if (_lastName != null) _lastName.length else 0

    var lengthB: Int = _lastName?.length ?: 0

//    SwingTest()

    var x = sayHi()
    println(x)
    sayHi()
    println(sayHi2())
    function()
    // Single Expression Function
    fun sayHelo() = println("Helo!!")
    sayHelo()

    val age = 23

    // as long as this doesn't go belong margin, single-line functions are preferable
    // THey take up much less space than expanding this across like 7 lines.
    fun doWork() = if (age != 21) println("Your age is not funny.") else println("tweny wan")

    doWork()

    // Function overloading with vararg - variable number of arguments
    fun printBookInfo(title: String, vararg authors: String) {
        print("$title, by ")
        // lambda expression for looping through authors
        authors.forEach{ print("$it ") } // it + ' '
    }

    printBookInfo("Pathway to Eden", "@starflower", "@earthrise", "@hollowmoon")

//    fun printThingy(stringy: String) {
//        print("Stringy: $stringy")
//    }

//    fun printThingy(stringy: String, numby: Int) {
//        print("Stringy: $stringy, numby: $numby")
//    }

//    fun printThingy(stringy: String, numby: Int, favDoubleVariable: Double) {
//        print("Stringy: $stringy, numby: $numby, favourite double variable: $favDoubleVariable")
//    }

    fun printThingy(stringy: String, numby: Int = 57, favDoubleVariable: Double = 0.57) {
        print("Stringy: $stringy, numby: $numby, favourite double variable: $favDoubleVariable")
    }

    printThingy("brah.mp4")

    var user = User()
    user.firstName = "Chloe"
    user.lastName = "Iforgotherna no wait it was Fortuna"

    var friend = User()
    friend.firstName = "Chloe"
    friend.lastName = "Fortuna"
    friend.printFullName()
    friend.printWithPrefix("poggers")

//    Button()
    
    // Multiple class constructors
    var user2 = TheCoolerUser("guy", "fieri")
    // Uses primary constructor
    var user3 = TheCoolerUser(firstName="gal", lastName="fierest", isPlatinum=true)
    // Calls into third constructor, then into second, then into root constructor
    var user4 = TheCoolerUser("gay") // me irl
    user2.printFullName()
    user3.printFullName()
    user4.printFullName()

    var user5 = Userer("Person", "Personska")
    println(user5.fullName)
    user5.fullName = "Jeff"
    println(user5.fullName)

//    ColorLabels()

    // ***************************************** 02/05/2023 *********************************************
    class Person(var name: String)

    var a = Person("donn")
    var b = Person("donn")

    println(a === b) // -> false
    println(a !== b); // -> true
    // different objects stored in different memory. old news, but good to refresh this knowledge <3

    // ******* Companion object
    // < check Userium.kt >
    // had to move it there, or else: "Modifier 'companion' is not applicable inside 'local class'"

    var userium = Userium("sus", "amogus")
    println(userium.fullName())
    println(userium.toString())

    // like a factory for creating objects
    val user6 = Userium.createUser("boo", "B")
    println(user6)

    val users1 = Userium.createUsers(7)
    println(users1)
    // collection helped method to make this prettier
    users1.forEach { println(it) }

    // we take from the companion object list that was modified by users1 call to createUsers
    val users2 = Userium.users
    users2.forEach { println(it) }

    // ******* How to create a Singleton

//    val x = FavouriteFood().instance()
    println(FavouriteFood.name)
    FavouriteFood.name = "Watermelon"
    println(FavouriteFood.name)

    fun doStuff() {
        FavouriteFood.name = "Chicken"
        FavouriteFood.ingredients.clear()
    }

    doStuff()
    println(FavouriteFood.name)
    // singleton -> 1 instance only

    FavouriteFood.ingredients.add("Salt")
    println(FavouriteFood.ingredients.first())
    println(FavouriteFood.numberOfIngredients())
    doStuff()
    println(FavouriteFood.ingredients.firstOrNull())
    println(FavouriteFood.numberOfIngredients())
    println(FavouriteFood == FavouriteFood)

    // ******* Declaring constants

    // back to < Userium.kt >
    val useru = Userium("Sapph", "Gay")
//    println(useru.MAX_AGE) // private
//    println(useru.MAX_AGE_2) // it's not in the instance
    println(Userium.MAX_AGE_2) // now *this* works
    // people like to do this:
    // < Constants.kt >
    println(Constants.MAX_AGE - Constants.MIN_AGE)
    // they can also be defined at the top level, above this main() function and App class
    Constants.ABC.split("").forEach { println(it) }

    // ******* The lateinit modifier
    // < LateInitUser.kt >

    val liu = LateInitUser("Donn", "Felker")
//    println(liu.toString())
    // Kotlin error:
    // Exception in thread "main" kotlin.UninitializedPropertyAccessException: You fucking lied to me
    liu.favouriteCity = "Minecraf"
    println(liu.toString())

    // ******* How to Nest Classes
    // ******* Inner classes

    // < Vehicle.kt >
    val myCar = Vehicle()
    myCar.brand = "Fiat"
    myCar.info()

    // after Inner classes section:
    // Constructor of inner class SteeringWheel can be called only with receiver of containing class
//    val sw = Vehicle.SteeringWheel()
    val sw = myCar.SteeringWheel()
    sw.info()

    var transmission = Vehicle.Transmission()
    transmission.shift()
    transmission.shift()

    // since Transmission is still a plain nested class, we cannot do that:
//    myCar.Transmission()
}

class TheCoolerUser(var firstName: String, var lastName: String, var isPlatinum: Boolean) {
    constructor(firstName: String, lastName: String) : this(firstName, lastName, false) {
        println("2nd")
    }

    constructor(firstName: String) : this(firstName, "Unknown") {
        println("3rd")
    }

    fun printFullName() {
        println("$firstName $lastName")
    }

    fun printWithPrefix(prefix: String) {
        print("$prefix $lastName")
    }

    fun updateName(newName: String) {
        firstName = newName
    }
}

class Jeff(var name: String)

// By default, all functions that don't have a return type, return Unit

fun sayHi() {
    println("hiiii :3")
}

fun sayHi2(): String {
    return "hiiii c:"
}

fun function() {
    println("Freddie: eeeooo")

//    nested() <- error! it's not been declared yet!

    fun nested() {
        println("The crowd: eeeee oooo")
    }

    nested()
}